"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[537],{1448:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return d}});var a=n(7896),r=n(1461),o=(n(2784),n(876)),i=["components"],s={sidebar_position:2},c="Asynchronous handlers",u={unversionedId:"guides/async",id:"guides/async",title:"Asynchronous handlers",description:"In most situations, you will have actions that run synchronously and directly update",source:"@site/docs/guides/async.md",sourceDirName:"guides",slug:"/guides/async",permalink:"/docs/guides/async",editUrl:"https://github.com/lukasbach/synergies/tree/main/packages/docs/docs/guides/async.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Basic Concepts",permalink:"/docs/guides/basic-concepts"},next:{title:"Nested Providers",permalink:"/docs/guides/nesting"}},l={},d=[],p={toc:d};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"asynchronous-handlers"},"Asynchronous handlers"),(0,o.kt)("p",null,"In most situations, you will have actions that run synchronously and directly update\nchanged atoms. However, you can also have actions that run asynchronously and which\ndepend on other delayed logic before changed atoms are updated. If you just need to\nrun asynchronous logic and update all atoms at the end, this is as easy as adding\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," keyword to the action handler."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const useFetchUser = createSynergy(userDataAtom, bearerTokenAtom)\n  .createAction(() => async (userData, bearerToken) => {\n    const user = await fetchUser(bearerToken.current);\n    userData.current = user;\n  });\n")),(0,o.kt)("p",null,"However, there are situations in which you want to update certain updates before the\ncomplete action has completed. You might be familiar with Hunks in Redux, which introduced\na similar concept. There, you could dispatch other synchronous actions while handling one\nasynchronous hunk action, to update pieces of the state early before the handler has completed."),(0,o.kt)("p",null,"In synergies, this is done differently: Because you don't just return updated atom states at\nthe end of the action, but rather update pieces of each atom state by writing to the draft state,\nthe state of the draft will change between lines. You can now trigger an update to any of the atoms\nwithin the synergy to flush any changes made to the draft so far to subscribing components, even\nbefore completing the action. The handler will then continue to complete the remaining action, and\nflush remaining atom changes at the end."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const useFetchUser = createSynergy(userDataAtom, bearerTokenAtom, isLoadingAtom)\n  .createAction(() => async (userData, bearerToken, isLoading) => {\n    isLoading.current = true;\n    // highlight-next-line\n    isLoading = isLoading.trigger();\n    const user = await fetchUser(bearerToken.current);\n    userData.current = user;\n    isLoading.current = false;\n  });\n")),(0,o.kt)("p",null,"In this example, components subscribing to the ",(0,o.kt)("inlineCode",{parentName:"p"},"isLoading")," atom will be updated at the beginning, and\nagain alongside components subscribing to the ",(0,o.kt)("inlineCode",{parentName:"p"},"userData")," atom at the end. Note that, flushing an atom\nstate will also reset its change state, so if it is not changed again, it will not trigger a re-render\nat the end again."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const useFetchUser = createSynergy(userDataAtom, isInitialRunAtom)\n  .createAction(() => async (userData, bearerToken, isInitialRun) => {\n    if (isInitialRun.current) return;\n\n    isInitialRun.current = true;\n    // highlight-next-line\n    isInitialRun = isInitialRun.trigger(); // updates isInitialRunAtom\n    \n    const user = await fetchUser();\n    userData.current = user;\n    // highlight-next-line\n    // Will update userDataAtom, but not isInitialRunAtom; That was updated earlier.\n  });\n")),(0,o.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Always remember to reassign atom drafts to the return value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"trigger()")," function.\nFlushing an atom state will complete the draft, and it will not be able to be written to\nagain, so you need to use the fresh draft copy of the atom state returned by ",(0,o.kt)("inlineCode",{parentName:"p"},"trigger()"),"\nto update it again."))))}h.isMDXComponent=!0},876:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return h}});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),u=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=u(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=u(n),h=r,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||o;return n?a.createElement(m,i(i({ref:t},l),{},{components:n})):a.createElement(m,i({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);