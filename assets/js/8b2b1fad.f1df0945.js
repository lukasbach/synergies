"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[126],{1310:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return u}});var o=n(7896),a=n(1461),r=(n(2784),n(876)),s=["components"],i={sidebar_position:1},c="Basic Concepts",l={unversionedId:"guides/basic-concepts",id:"guides/basic-concepts",title:"Basic Concepts",description:"The following will explain the basic concepts of synergies and how they are used.",source:"@site/docs/guides/basic-concepts.md",sourceDirName:"guides",slug:"/guides/basic-concepts",permalink:"/docs/guides/basic-concepts",editUrl:"https://github.com/lukasbach/synergies/tree/main/packages/docs/docs/guides/basic-concepts.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Get Started",permalink:"/docs/getstarted"},next:{title:"Asynchronous handlers",permalink:"/docs/guides/async"}},d={},u=[{value:"Atoms",id:"atoms",level:2},{value:"Synergies",id:"synergies",level:2},{value:"Selectors",id:"selectors",level:2},{value:"Actions",id:"actions",level:2},{value:"Providers and Provider Nesting",id:"providers-and-provider-nesting",level:2},{value:"Initial State of Atoms",id:"initial-state-of-atoms",level:2}],p={toc:u};function m(e){var t=e.components,n=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"basic-concepts"},"Basic Concepts"),(0,r.kt)("p",null,"The following will explain the basic concepts of synergies and how they are used."),(0,r.kt)("h2",{id:"atoms"},"Atoms"),(0,r.kt)("p",null,"An atom is an abstract unit of data. It defines a kind of data, and can be used\nat one or several different points in your application to store different values of the same type\nof data."),(0,r.kt)("p",null,"One example for a reusable state atom is an ",(0,r.kt)("inlineCode",{parentName:"p"},"isExpandedAtom")," that stores whether a popover\nmenu is expanded or not. This atom can be used for arbitrarily many different menus to determine\nwhether the respective menu is expanded or not. All instances of this atom will store the same kind\nof data, but can still have differing values between each other. For the atom to be used at different\npoints in your application, it needs to be provided in disjunctive subtrees within your React component tree."),(0,r.kt)("p",null,"State atoms don't need to focus on reusability. You can also define atoms that are meant for storing\nglobal information, such as authentication data or user information. You will need to provide those\natoms at the top of your component tree to make sure they are available everywhere."),(0,r.kt)("p",null,"To create atoms, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"createAtom")," utility with an initial value and an optional name that is\nused for debugging."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'const valueAtom = createAtom("Initial Value");\nconst todosAtom = createAtom([], "todos"); // second parameter is an optional name\n')),(0,r.kt)("h2",{id:"synergies"},"Synergies"),(0,r.kt)("p",null,"When interacting with state, you typically do not use single atoms at once. You usually specify\nhow multiple atoms work together, and you can do so by creating a synergy of them and acting on\nthe synergy instead of the atom."),(0,r.kt)("p",null,"You can create a new synergy of atoms by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"createSynergy")," utility."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const synergy = createSynergy(valueAtom, todosAtom);\n")),(0,r.kt)("p",null,"You can synergyze as many atoms as you want. When synergyzing atoms, the order in which the atoms\nare passed is important: When you use the synergy to define actions or selectors, those will receive\nthe state of the atoms in the same order as specified when creating the synergy."),(0,r.kt)("p",null,"One important thing to note is that synergies themselves are stateless; You do not need to create them\nonce and define your interaction logic on one and the same synergy. You can create new synergies on the\nfly, and choose differing combinations of atoms for each of them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"// Works, but not necessary\nconst synergy = createSynergy(valueAtom, todosAtom);\nconst useAddTodo = synergy.createAction(...);\nconst useClearInput = synergy.createAction(...);\n\n// Create synergies on the fly, always use the atoms you really need\nconst useAddTodo = createSynergy(valueAtom, todosAtom).createAction(...);\nconst useClearInput = createSynergy(valueAtom, focusAtom).createAction(...);\nconst useFetchTodos = createSynergy(todosAtom, bearerTokenAtom).createAction(...);\n")),(0,r.kt)("p",null,"You might have seen that atoms and synergies share a lot of methods. This is because every atom\nis also a synergy of itself. This means you can directly create interactions on an atom if you don't\nneed the interaction to depend on the state of other atoms, instead of creating a new synergy."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const useCurrentValue = createSynergy(valueAtom).createSelector(...);\n// is the same as\nconst useCurrentValue = valueAtom.createSelector(...);\n")),(0,r.kt)("h2",{id:"selectors"},"Selectors"),(0,r.kt)("p",null,"To read data from state, define a selector on a synergy of atoms, and use the created React hook\nin your component to read the current value of the selector."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const useFilteredTodos = createSynergy(searchAtom, todosAtom)\n  .createSelector((search, todos) => \n    todos.filter(todo => todo.includes(search))\n  );\n")),(0,r.kt)("p",null,"You can now use the ",(0,r.kt)("inlineCode",{parentName:"p"},"useFilteredTodos")," hook in any component to read the current value of the\nselector result. Whenever any atom, that is part of the synergy on which the selector was created\non, is updated, the hook will be re-rendered with the new value of the selector."),(0,r.kt)("p",null,"If you just want to read the value of a single atom without any selector logic, you can also use\n",(0,r.kt)("inlineCode",{parentName:"p"},"searchAtom.useValue()")," as React hook to directly subscribe to a single atoms state value."),(0,r.kt)("h2",{id:"actions"},"Actions"),(0,r.kt)("p",null,"To update state, define an action on a synergy of atoms, and use the created React hook\nin your component to get an action handler that dispatches the action. The basic gist is\nsimilar to selectors, with some very important differences:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Actions can require arguments to be called which are used in their implementation.\nSelectors always statically return state."),(0,r.kt)("li",{parentName:"ul"},"Selectors directly return a reference for each atom. Actions return an immutable draft for\nevery atom state, that can be directly modified or read."),(0,r.kt)("li",{parentName:"ul"},"Selectors are synchronous hooks that directly return the value. Actions can be asynchronous\nhandlers that can be called and waited on."),(0,r.kt)("li",{parentName:"ul"},"Synergies always rerender whenever any of the atoms in the synergy changes. Actions only\ntrigger rerenders for atoms that they actually change.")),(0,r.kt)("p",null,"For now, we will focus on synchronous actions. How asynchronous actions work will be detailed\nin ",(0,r.kt)("a",{parentName:"p",href:"async"},"the section about asynchronous handlers"),"."),(0,r.kt)("p",null,"The final bullet point is particularly important for performance: Since action handlers use\ndrafts of each atom state, they will detect which atoms are changed and which are not. If an\naction uses one atom only to read its value, but do not modify it, this atom will not be updated\nand components reading from it will not be re-rendered. This is important to avoid unnecessary\nre-renders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const useTickTodo = createSynergy(todosAtom, tickedTodosAtom)\n  .createAction(index => (todos, tickedTodos) => {\n    // tickedTodosAtom was updated and will trigger a re-render\n    // todosAtom was only read from and will not trigger a re-render\n    tickedTodos.current.push(todos[index]);\n  });\n")),(0,r.kt)("p",null,"You can then use the hook to get an action handler that dispatches the action."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const Todo = ({ value, index }) => {\n  // highlight-next-line\n  const tick = useTickTodo();\n  return (\n    <TodoItem onClick={() => tick(index)}>\n      { value }\n    </TodoItem>\n  )\n}\n")),(0,r.kt)("h2",{id:"providers-and-provider-nesting"},"Providers and Provider Nesting"),(0,r.kt)("p",null,"The state of atoms is stored in React Context, which is supplied by Synergy Providers.\nMount a provider in your component tree, to make a number of atoms available in any components\nwithin its subtree."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"<SynergyProvider atoms={[todosAtom, tickedTodosAtom, inputAtom]}>\n  <TodoList />\n  <TodoInput />\n</SynergyProvider>\n")),(0,r.kt)("p",null,"If the list becomes too long, you can also combine atoms into synergies beforehand\nand pass in synergies instead of atoms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const todosSynergy = createSynergy(todosAtom, tickedTodosAtom, inputAtom);\n\n<SynergyProvider atoms={[todosSynergy]}>\n  <TodoList />\n  <TodoInput />\n</SynergyProvider>\n")),(0,r.kt)("p",null,"You can mount as many synergy providers as you want. Each provider will pass through\nstate of atoms of other providers further up the component hierarchy. When you create\na synergy, it doesn't have to exclusively use atoms from the same provider. You can\nmix and match atoms from different providers, as long as they are all available in the\ncomponent where the action or selector hooks are used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"// highlight-next-line\n<SynergyProvider atoms={[todosAtom, tickedTodosAtom]}>\n  {/* Can use only todosAtom and tickedTodosAtom */}\n  <TodoList />\n  // highlight-next-line\n  <SynergyProvider atoms={[inputAtom]}>\n    {/* Can use all three atoms */}\n    <TodoInput />\n  </SynergyProvider>\n</SynergyProvider>\n")),(0,r.kt)("p",null,"More details on nested providers and localized state reuse is given\nin ",(0,r.kt)("a",{parentName:"p",href:"nesting"},"the section about nested providers"),"."),(0,r.kt)("h2",{id:"initial-state-of-atoms"},"Initial State of Atoms"),(0,r.kt)("p",null,"Apart from specifying a default state for each atom at the time of creation, you can also\nsupply an initial state to the provider, either by directly declaring it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'<SynergyProvider \n  atoms={[todosAtom, tickedTodosAtom]}\n  // highlight-start\n  initialState={{\n    [tickedTodosAtom.id]: ["initiallyTicked!"],\n    [todosAtom.id]: ["initiallyTicked!"]\n  }}\n  // highlight-end\n>\n  {/* ... */}\n</SynergyProvider>\n')),(0,r.kt)("p",null,"or by using the type-helper in the atom class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'<SynergyProvider \n  atoms={[todosAtom, tickedTodosAtom]}\n  // highlight-start\n  initialState={{\n    ...tickedTodosAtom.createInitialValue(["initiallyTicked!"])\n    ...todosAtom.createInitialValue(["initiallyTicked!"])\n  }}\n  // highlight-end\n>\n  {/* ... */}\n</SynergyProvider>\n')))}m.isMDXComponent=!0},876:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=l(n),m=a,y=p["".concat(c,".").concat(m)]||p[m]||u[m]||r;return n?o.createElement(y,s(s({ref:t},d),{},{components:n})):o.createElement(y,s({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);