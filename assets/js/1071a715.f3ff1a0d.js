"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[107],{1322:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var o=n(7896),r=n(1461),i=(n(2784),n(876)),a=["components"],s={sidebar_position:3},l="Nested Providers",c={unversionedId:"guides/nesting",id:"guides/nesting",title:"Nested Providers",description:"As mentioned in the section about basic concepts, one important",source:"@site/docs/guides/nesting.md",sourceDirName:"guides",slug:"/guides/nesting",permalink:"/docs/guides/nesting",editUrl:"https://github.com/lukasbach/synergies/tree/main/packages/docs/docs/guides/nesting.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Asynchronous handlers",permalink:"/docs/guides/async"},next:{title:"State Logic Reuse",permalink:"/docs/guides/reuse"}},u={},p=[{value:"Reuse of Local State",id:"reuse-of-local-state",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,a);return(0,i.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"nested-providers"},"Nested Providers"),(0,i.kt)("p",null,"As mentioned in ",(0,i.kt)("a",{parentName:"p",href:"docs/guides/basic-concepts"},"the section about basic concepts"),", one important\nfeature of synergies is the ability to have multiple state providers, and nest them based on\nthe hierarchical structure of your app."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"// highlight-next-line\n<SynergyProvider atoms={[todosAtom, tickedTodosAtom]}>\n  {/* Can use only todosAtom and tickedTodosAtom */}\n  <TodoList />\n  // highlight-next-line\n  <SynergyProvider atoms={[inputAtom]}>\n    {/* Can use all three atoms */}\n    <TodoInput />\n  </SynergyProvider>\n</SynergyProvider>\n")),(0,i.kt)("p",null,"In this example, there are two nested providers, the upper one provides the atoms ",(0,i.kt)("inlineCode",{parentName:"p"},"todosAtom")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"tickedTodosAtom"),", and the lower one provides the atom ",(0,i.kt)("inlineCode",{parentName:"p"},"inputAtom"),". The component ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoInput />"),"\nand everything else within the lower provider has access to all three atoms, whereas components\nthat are in the upper provder, but not the lower one, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoList />"),", will only have access\nto the atoms ",(0,i.kt)("inlineCode",{parentName:"p"},"todosAtom")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tickedTodosAtom"),"."),(0,i.kt)("p",null,"Consider the following actions derived from certain synergies:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'const useAddTodo = createSynergy(todosAtom, inputAtom)\n  .createAction(() => (todos, input) => {\n    todos.current.push(input.current);\n    input.current = "";\n  });\n')),(0,i.kt)("p",null,"The hook ",(0,i.kt)("inlineCode",{parentName:"p"},"useAddTodo")," will be able to be called within the ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoInput />")," component and everything\nelse in the lower provider, because it has all atoms available. It doesn't matter that the atoms\nit synergizes, ",(0,i.kt)("inlineCode",{parentName:"p"},"todosAtom")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"inputAtom"),", are in different providers, it suffices that they are in\nthe same React subtree. However, the hook will not be able to be called in ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoList />"),", since\nit doesn't have access to the atom ",(0,i.kt)("inlineCode",{parentName:"p"},"inputAtom"),"."),(0,i.kt)("p",null,"One benefit of that is that you get to keep your global state clean. You can still provide global\nstate at the top of your component hierarchy, like user information or authentication details,\nbut get to keep more localized state in the lower providers. Furthermore, it allows you to reuse\nlocal state information in multiple places, as long as are mounted in disjunct subtrees."),(0,i.kt)("h2",{id:"reuse-of-local-state"},"Reuse of Local State"),(0,i.kt)("p",null,"A common use case for reusing local state in React context is to store information of small contained\ncomponent compositions, which serve a very specific purpose, but still are composed of several components.\nThis allows the consumer of the components to still mount them with more control over how they are organized."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'<SynergyProvider atoms={[authAtom, userDataAtom]}>\n  // highlight-next-line\n  <SynergyProvider atoms={[selectedItemAtom, isExpandedAtom]}>\n    <MenuImplementation name="File" />\n  </SynergyProvider>\n\n  // highlight-next-line\n  <SynergyProvider atoms={[selectedItemAtom, isExpandedAtom]}>\n    <MenuImplementation name="Edit" />\n  </SynergyProvider>\n</SynergyProvider>\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://chakra-ui.com/"},"chakra-ui")," is a good example for this pattern, since they use it a lot in their\ncomponents. Consider a menu component similar to ",(0,i.kt)("a",{parentName:"p",href:"https://chakra-ui.com/docs/components/overlay/menu#usage"},"chakra-ui's implementation"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"<Menu>\n  <MenuButton>\n    Menu Button\n  </MenuButton>\n  <MenuList>\n    <MenuItem>Download</MenuItem>\n    <MenuItem>Create a Copy</MenuItem>\n    <hr />\n    <MenuItem>Mark as Draft</MenuItem>\n  </MenuList>\n</Menu>\n")),(0,i.kt)("p",null,"In this case, you can define state information in the menu container component, that will\nbe provided through React context to child components within that container. Here, synergies\ncan be used to easily define this localized state that will be used only in that component,\nwithout interfering with other menu instances within the same page."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const isOpenAtom = createAtom(false);\nconst focusedItemAtom = createAtom(-1);\nconst buttonRefAtom = createAtom(null);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const Menu = ({ children }) => (\n  <SynergyProvider atoms={[isOpenAtom, focusedItemAtom, buttonRefAtom]}>\n    {children}\n  </SynergyProvider>\n);\n")),(0,i.kt)("p",null,"That is all you need to do to define your context state and pass it to children. The usual\nboilerplate stuff like defining the context, defining custom context hooks, defining a custom\ncontext provider and memoizing the context state is all done for you. And even then performance\nwill be better than with native contexts since synergies still optimizes state updates in cases\nof multiple atoms. "),(0,i.kt)("p",null,"Then, create action and selector hooks to interact with the context state, and use the state\nin the child components."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"const MenuButton = ({ children }) => {\n  const setRef = buttonRefAtom.useSet();\n  const setIsOpen = isOpenAtom.useSet();\n  const [isOpen] = isOpenAtom.useValue();\n  \n  return (\n    <Button\n      pressed={isOpen}\n      onClick={() => setIsOpen(!isOpen)}\n      ref={setRef}\n    >\n      {children}\n    </Button>\n  )\n}\n")))}m.isMDXComponent=!0},876:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var o=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?o.createElement(h,a(a({ref:t},u),{},{components:n})):o.createElement(h,a({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);